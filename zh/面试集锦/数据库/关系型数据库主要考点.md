# 关系型数据库主要考点

- 架构
- 索引
- 锁
- 语法
- 理论范式

## 如何设计我们自己的数据库（包括哪些部分）？

![](assert\2019-08-22_09-46-45.png)

## 索引模块

### 1、为什么要使用索引?

​	索引是一种数据结构,相当于目录，可以帮助我们快速的进行数据查找，提升检索效率

### 2、什么样的信息能成为索引？

1. 建立索引的时候一般要考虑到字段的使用频率，经常作为条件进行查询并且区分性比较高的字段比较适合建索引
2. 如果需要建立联合索引的话,还需要考虑联合索引中的顺序
3. 此外也要考虑其他方面,比如防止过多的索引对表造成太大的压力，这些都和实际的表结构以及查询方式有关.

### 3、索引的数据结构有哪些?

B+树(主流)

Hash索引（innodb和MyISAM不显示支持）

bitMap位图索引(Mysql不支持)

### 5、为什么使用B+Tree作为索引?

![](assert\2019-08-22_10-45-23.png)

### 6、如何定位并优化慢查询sql

> 参考链接: [MySQL如何定位并优化慢查询sql](https://www.pianshen.com/article/92571677725/)

①根据慢日志定位慢查询sql

 SHOW (global | session [不写默认session])  VARIABLES LIKE ‘%query%’ 查询慢日志相关信息 

( global 设置完需要重新连接数据库，PS：仅在这里改的话，当再次重启数据库服务时，所有设置又会自动恢复成默认值，永久改变需去my.ini中改） 

-  slow_query_log 默认是off关闭的，使用时，需要改为on 打开　　　　　　
-  slow_query_log_file 记录的是慢日志的记录文件
-  long_query_time 默认是10S，每次执行的sql达到这个时长，就会被记录
-  Slow_queries   记录的是慢查询数量 

②使用explain等工具分析sql

-  在要执行的sql前加上explain 例如：EXPLAIN SELECT menu_name FROM t_sys_menu ORDER BY menu_id    DESC; 

③修改sql或者尽量让sql走索引

![2021-04-06_10-12-48](assert\2021-04-06_10-12-48.png)

接着看explain的关键字段

type：

如果发现type的值是最后两个中（index | all）的其中一个时，证明语句需要优化了。

extra：

c.修改sql或者尽量让sql走索引
　　　　mysql查询优化器会根据具体情况自己判断走哪个索引，不一定是走主键（explain中的key可以看到走的哪个key）具体情况根据具体情况来定，当你要强制执行走某一个key时：

在查询的最后加上 force index(primary); 强制走主键的

![](assert\2019-08-22_15-22-27.png)
**index : 遍历了整颗索引树**

**all: 全表扫描**

![](assert\2019-08-22_15-29-56.png)

![](assert\2019-08-22_15-50-09.png)

## Mysql锁模块

![](assert\2019-08-22_15-56-17.png)

![](assert\2019-08-22_16-01-57.png)

### MyISAM与InnoDB关于锁方面的区别是什么?

- **MyISAM(不支持事务)默认用的是表级锁,不支持行级锁**

- **InnoDB(支持事务)默认用的是行级锁,也支持表级锁**

  （InnoDB）行锁申请：

    向InnoDB申请写锁(排他锁)InnoDB会先申请整张表的意向排他锁(先检测表上是否有意向排他锁，没有直接申请成功，有的话扫描你要加锁的那一行是否加了排他锁，有的话阻塞，没有的话申请成功)，成功后再申请行的行锁(意向锁之间互相兼容IS(意向共享锁) IX(意向排他锁))

![](assert\2019-08-22_16-58-27.png)

![](assert\2019-08-22_17-00-53.png)

![](assert\2019-08-22_17-01-45.png)

![](assert\2019-08-22_17-22-41.png)

### 事务的隔离级别及其并发访问问题

**一、事务的基本要素（ACID）**

　　**1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。**

　　 **2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。**

　　 **3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**

　　 **4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。**

 

**二、事务的并发问题**

　　**1、脏读：事务A读取了事务B未提交的数据，那么A读取到的数据是脏数据**

　　**2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。**

　　**3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。**

　　**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表** 



> **第一类丢失更新，**A事务撤销时，把已经提交的B事务的更新数据覆盖了
>
> **第二类丢失更新**，B事务覆盖A事务已经提交的数据，造成A事务所做操作丢失

**三、MySQL事务隔离级别**

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 第一类丢失更新(回滚) | 第二类丢失更新 |
| ---------------------------- | ---- | ---------- | ---- | -------------------- | -------------- |
| 读未提交（read-uncommitted） | 允许 | 允许       | 允许 | 禁止                 | 允许           |
| 读已提交（read-committed）   | 禁止 | 允许       | 允许 | 禁止                 | 允许           |
| 可重复读（repeatable-read）  | 禁止 | 禁止       | 允许 | 禁止                 | 禁止           |
| 串行化（serializable）       | 禁止 | 禁止       | 禁止 | 禁止                 | 禁止           |

> mysql默认的事务隔离级别为 ：**可重复读**【repeatable-read】

![](assert\2019-08-22_20-07-52.png)

![](assert\2019-08-22_20-18-27.png)

![](assert\2019-08-22_21-04-33.png)

![](assert\2019-08-22_21-05-14.png)

![](assert\2019-08-28_09-41-17.png)

> 当前读中
>
> Next-Key锁(行锁+gap锁)
>
> 当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙(GAP)"。InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)

![](assert\2019-08-22_20-59-17.png)

### 什么是MVCC

https://www.cnblogs.com/chenyu1412/p/15617028.html



### 锁小结

![](assert\2019-08-22_21-07-59.png)

## 关键语法

**group by** 

**having**